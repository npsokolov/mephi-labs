# Pfibers

В этой задаче нужно написать библиотеку пользовательских потоков с вытесняющей многозадачностью.

В пользовательском коде аналогами прерываний являются сигналы.
С помощью системного вызова `ualarm` можно настроить доставку сигнала `SIGALRM` с высокой частотой и использовать это для принудительного переключения между файберами.

В отличие от кода ядра ОС, где обработчик прерывания должен сам сохранить пользовательские регистры, в случае обработки сигналов весь предыдущий контекст исполнения уже находится на стеке.
Это удобно при обычной работе с сигналами, но нам как раз нужны сами регистры, чтобы заменить контекст.
Структура сохранённого контекста на стеке описана в файле `arch/x86/include/uapi/asm/sigcontext.h` ядра Linux.
В этой задаче понадобится только начало:

```c
struct sigframe {
    long r8, r9, r10, r11, r12, r13, r14, r15;
    long rdi, rsi, rbp, rbx, rdx, rax, rcx, rsp;
    long rip, flags;
};
```

Сперва вам нужно будет найти на стеке `struct sigframe`.
Переделайте своё решение задачи `fibers` так, чтобы при получении сигнала `SIGALRM` происходило переключение контекста.

В x86\_64 ABI есть требование, что при вызове функции перед выполнением инструкции call (до того как адрес возврата будет положен на стек) стек должен быть выровнен на 16.
Запись адреса возврата сбивает выравнивание, но после того, как функция выполит `push %rpb` стек снова окажется выровненным на 16.
Это нужно, чтобы функция могла работать с xmm регистрамми и стеком (такое встречается в оптимизированном коде, в частности, в libc).
Если стек окажется не выровненым, то могут возникнуть ошибки segmentation fault и bus error.
Под санитайзером это может проявляться как ASAN:DEADLYSIGNAL.
В обычном коде стек уже подготовлен операционной системой и рантаймом и вы просто его используете.
В этом же задании мы делаем свой стек, поэтому за выравниванием нужно следить самостоятельно.
